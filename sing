#!/bin/sh

escape() { 
    echo "$1" | sed 's/\([\.\$\*]\)/\\\1/g'
}

warn() {
    echo "$@" >&2;
}

die() { 
    warn "$@"
    exit 1
}

has() {
    local item=$1
    shift
    echo " $@ " | grep -q " $(escape $item) "
}

local_branches() { 
    git branch --no-color | sed 's/^[* ] //'
}

current_branch() {
	git branch --no-color | grep '^\* ' | grep -v 'no branch' | sed 's/^* //g'
}

checkout() {
    echo "git checkout $@"
    git checkout "$@" || die
}

rebase() {
    echo "git rebase $@"
    git rebase "$@" || die
}

svn_rebase() {
    echo "git svn rebase $@"
    git svn rebase "$@" || die
}

cmd_update() {
    if test "$CURRENT" = "$MASTER"; then
	svn_rebase
    else
	checkout "$MASTER"	    
	svn_rebase

	checkout "$CURRENT"
	rebase "$MASTER"
    fi
}

usage() {
    echo "usage: sing <subcommand>"
    echo "available subcommands: update - first rebases '$MASTER' on the SVN head revision, then the current branch on '$MASTER'"
}

main() {
    CURRENT="$(current_branch)"
    MASTER="master"

    # basic sanity checks
    if test $# -eq 0; then
	usage
	die
    fi

    if test "$1" = "usage"; then
	usage
	exit 0
    fi

    if ! git rev-parse --git-dir >/dev/null 2>&1; then
	die "error: Not a git repository"
    fi

    if ! has $MASTER $(local_branches); then
	die "error: branch $MASTER not found"
    fi
    
    if ! git diff --no-ext-diff --ignore-submodules --quiet --exit-code; then
	die "error: working tree contains unstaged changes, aborting"
    fi

    if ! git diff-index HEAD --ignore-submodules --quiet --exit-code; then
	die "error: index contains uncommited changes, aborting"
    fi
    
    # delegate to subcommands
    # save first subcommand and remove it from the given arguments 
    SUBCOMMAND="$1"
    shift
    
    cmd_$SUBCOMMAND "$@"
    
    if test $? -eq 127; then
	usage
	die
    fi
}

main "$@"
